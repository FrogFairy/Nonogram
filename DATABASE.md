# Установка Sqlite Studio

1. Скачиваем SQLiteStudio с официального сайта: <https://sqlitestudio.pl/>
2. Устанавливаем

Чтобы посмотреть базу данных:
1. В SQLiteStudio открываем нашу базу (База данных -> Добавить базу данных. Вводим путь к nonogram.db)
2. Слева появится база данных. Нажимаем на нее дважды, далее нажимаем на levels - нашу основную (и единственную) табличку.
3. Для просмотра записей, которые есть в базе данных нажимаем на Данные (в верхней части экрана)


# create_level.h

Из этого файлика понадобится функция

```c++
create_matrix_level(int w, int h, const std::string& filename)
```

Она создает 
```c++ 
vector<vector<int>>
```
массив значений ячеек, полученных из изображения. **w** и **h** - размеры уровня, **filename** - путь к изображению, из которого необходимо получить массив.

Значения пикселей:
- -1 - пустота (может появится только в массиве, который отображает действия пользователя). Т.е. пользователь ничего не поставил в эту ячейку
- 0 - крестик
- 1 - закрашенный
- 2 - крестик от подсказки
- 3 - закрашенный от подсказки


# Структура Level (database.h)

Это структура нашего уровня. Содержит те же поля, что и в табличке levels в базе данных.

По умолчанию поля **title** и **size** заданы пустыми строками, **correct_values** и **current_values** - пустыми векторами, **hearts_count** - 3, **finished** - false.

Благодаря этому можно передавать в конструктор не все поля, а лишь известные (это будет title, size и correct_values).

Пример создания экземпляра этого класса:

```c++
Level level{"hamster level", "30x30", create_matrix_level(30, 30, "resources/hamster.jpg")};
```


# Структура Database_levels (database.h)
Структура для работы с базой данных.

Создание экземпляра класса:
```c++
Database_levels db_levels{};
```

Структура содержит перечисление Response (ответ) с тремя элементами: **OK**, **ALREADY_EXISTS**, **FAIL**. Второй элемент означает, что уровень с таким названием и размером уже существует, третий элемент означает ошибку при работе с базой данных.

Метод
```c++
Response add_level(Level level)
```
добавляет новый уровень в базу данных. В аргументы передаем экземпляр класса уровня. В этом методе проиходит проверка на существование уровня с переданными названием и размером. При существовании переданного уровня метод вернет
```c++
Response::ALREADY_EXISTS
```

Метод
```c++
Level get_level(const std::string& title, const std::string& size)
```
возвращает найденный в базе данных по названию и размеру уровень. 
Если такого уровня не существует или произошла ошибка при работе с базой данных, метод вернет **Level** со всеми полями, заданными по умолчанию.

Метод
```c++
int get_new_id(const std::string& size);
```
считает в базе данных все уровни размера **size** и возвращает значение, на единицу большее этого количества. Т.е. это значение можно использовать для названия уровня по умолчанию (в нашем случае это будет "{id} level"). При ошибке работы с базой данных метод вернет 0.

Пример использования этой структуры:

```c++
Level level{"hamster level", "30x30", create_matrix_level(30, 30, "resources/hamster.jpg")};
Database_levels db_levels{};
Database_levels::Response res = db_levels.add_level(level);
if (res == Database_levels::Response::ALREADY_EXISTS)
    std::cout << "cool!" << std::endl;
Level hamster_level = db_levels.get_level("hamster level", "30x30");
std::cout << hamster_level.title << " " << hamster_level.size << " " << hamster_level.hearts_count << " " << hamster_level.finished << std::endl;
std::cout << db_levels.get_new_id("30x30") << std::endl;
```